# 6장 객체와 자료 구조
- 변수를 private 로 정의하는 이유는 의존성을 줄이기 위함이다.
- 근데 왜 getter, setter 를 public 으로 사용할까?

## 자료 추상화
- 변수를 private 로 선언해도 get, set 이 공개되어있다면 외부노출과 다르지 않다.
- 구현을 감추기 위해서는 추상화가 필요하다.
- 사용자가 구현을 몰라도 추상 인터페이스를 사용해 자료의 핵심을 조작할 수 있어야한다.
- 자료는 세세하게 공개하기 보다 추상적인 개념으로 표현하는게 좋다.
- 개발자는 객체가 포함하는 자료를 표현할 방법을 고민해야한다.

## 자료/객체 비대칭
- 객체와 자료구조의 정의는 서로 상반된다.
  - 객체는 추상화 뒤로 객체를 숨기고 자료를 다루는 함수만 공개한다.
  - 자료구조는 자료를 그대로 공개하며 함수는 제공하지 않는다.
- 절차적인 코드와 객체지향 코드도 서로 상반된다.
  - 절차적인 코드는 자료 구조 변경 없이 새 함수를 추가하기 쉽지만 새로운 자료구조를 추가하기 어렵다.
  - 객체지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽지만 새로운 함수를 추가하기는 어렵다.
- 객체지향 코드에서의 쉬운 변경은 절차적인 코드에서 쉽고, 절차적인 코드에서 쉬운 변경은 객체지향에서 어렵다는 의미

## 디미터 법칙
- `모듈은 자신이 조작하는 객체의 속사정을 잘 몰라야 한다` 는 법칙으로
    
    객체는 조회 함수로 내부 구조를 공개하면 안된다는 의미이다.
    >ex) 클래스 C의 메서드 f는 다음의 객체의 메서드만 호출해야한다.
  > - 클래스 C
  > - f가 생성한 객체
  > - f 인수로 넘어온 객체
  > - C 인스턴스 변수에 저장된 객체
  - 하지만 위의 객체에서 허용된 메서드가 반환하는 객체의 메서드는 호출하면 안된다.

### 기차 충돌
```Java
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```
- 위와 같은 코드를 `기차 충돌` 이라 한다.
- 여러 객체가 한줄로 이어져 조잡하게 보일 수 있어 피하는게 좋다.
- 자료 구조는 공개 변수만, 객체는 비공개 변수, 공개함수 를 포함하면 쉽지만 아닌 경우도 존재한다.

### 잡종 구조
- 절반은 객체, 절반은 자료 구조 같은 잡종 구조가 나올 수 있다.
- 객체와 자료 구조가 섞인 구조는 새로운 함수나 자료구조 추가 모두 어렵다.

### 구조체 감추기
- 객체는 자신이 뭔가 하려고 한다는걸 드러내면 안된다.
- 가능하다면 목적 달성을 위한 코드를 객체 내부에 작성해서 내부 구조를 드러내지 않고, 작업할 수 있게 만들자.

## 자료 전달 객체
- 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스,

    이러한 구조체를 자료 전달 객체(DTO) 라고 하고, 보다 일반적인 형태는 `빈` 구조다.

### 활성 레코드
- DTO의 특수한 형태로, 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료구조를 활성 레코드라한다.

    - save, find 같은 탐색 함수도 제공한다.
- 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다.
- 활성 레코드는 자료구조로 취급해 비즈니스 규칙 메서드를 추가하지 않아야한다.

## 결론
- 객체
  - 동작을 공개하고, 자료를 숨긴다.
  - 새 객체 타입을 추가하기는 쉽지만 기존 객체에 새 동작 추가는 어렵다.
- 자료구조
  - 별 다른 동작 없이 자료를 노출한다.
  - 기존 자료 구조에 새 동작 추가는 쉽지만 기존 함수에 새 자료 구조 추가는 어렵다.

####
- 시스템을 구현할 때 자료 타입 추가에 대한 유연성은 객체와 객체지향적 코드로,

    동작 추가에 대한 유연성은 자료 구조와 절차적 코드로 작성하는게 좋다.